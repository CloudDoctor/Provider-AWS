<?php

namespace CloudDoctor\Amazon;

use Aws\Ec2\Ec2Client;
use Aws\Ec2\Exception\Ec2Exception;

class SecurityGroup
{
    /** @var string */
    private $name;
    /** @var string[] */
    private $applicableVpcIds = [];
    /** @var SecurityGroupRule[] */
    private $rulesInbound = [];
    /** @var SecurityGroupRule[] */
    private $rulesOutbound = [];
    /** @var string[] */
    private $awsSecurityGroupIds = [];

    public static function Factory() : SecurityGroup
    {
        return new SecurityGroup();
    }

    /**
     * @return string[]
     */
    public function getAwsSecurityGroupIds(): array
    {
        return $this->awsSecurityGroupIds;
    }

    /**
     * @param string[] $awsSecurityGroupIds
     *
     * @return SecurityGroup
     */
    public function setAwsSecurityGroupIds(array $awsSecurityGroupIds): SecurityGroup
    {
        $this->awsSecurityGroupIds = $awsSecurityGroupIds;
        return $this;
    }

    public function addAwsSecurityGroupIdByRegion(string $region, string $value): SecurityGroup
    {
        $this->awsSecurityGroupIds[$region] = $value;
        return $this;
    }

    public function getAwsSecurityGroupIdByregion(string $region) : ?string
    {
        return $this->awsSecurityGroupIds[$region] ?: null;
    }

    /**
     * @return string[]
     */
    public function getApplicableVpcIds(): array
    {
        return $this->applicableVpcIds;
    }

    /**
     * @param string[] $applicableVpcIds
     *
     * @return SecurityGroup
     */
    public function setApplicableVpcIds(array $applicableVpcIds): SecurityGroup
    {
        $this->applicableVpcIds = $applicableVpcIds;
        return $this;
    }

    public function assert(Request $request) : SecurityGroup
    {
        $sg = $this;
        $request->acrossRegionAction(function (string $region, Ec2Client $ec2Client) use ($sg) {
            $vpcId = $this->getApplicableVpc($ec2Client);
            $exists = false;
            $allSecurityGroups = $ec2Client->describeSecurityGroups()->get('SecurityGroups');
            foreach ($allSecurityGroups as $ec2SecurityGroup) {
                if ($ec2SecurityGroup['GroupName'] == $sg->getName()) {
                    $exists = true;
                    $groupId = $ec2SecurityGroup['GroupId'];
                }
            }

            if (!$exists) {
                $makeGroupResponse = $ec2Client->createSecurityGroup([
                    'GroupName' => $sg->getName(),
                    'Description' => sprintf(
                        "Automatically generated by MEDIC at %s",
                        date("Y-m-d H:i:s")
                    ),
                    'VpcId' => $vpcId,
                ]);
                $groupId = $makeGroupResponse->get('GroupId');
            }

            $sg->addAwsSecurityGroupIdByRegion($region, $groupId);

            $group = $ec2Client->describeSecurityGroups([
                'Filters' => [
                    [
                        'Name' => 'group-id',
                        'Values' => [$groupId],
                    ]
                ]
            ])->get('SecurityGroups')[0];

            foreach ($sg->getRulesInbound() as $inboundRule) {
                $protocols = [];
                $ipPermissions = [];
                switch ($inboundRule->getProtocol()) {
                    case "all":
                    case "any":
                        $protocols[] = 'tcp';
                        $protocols[] = 'udp';
                        break;
                    case SecurityGroupRule::PROTOCOL_TCP:
                        $protocols[] = 'tcp';
                        break;
                    case SecurityGroupRule::PROTOCOL_UDP:
                        $protocols[] = 'udp';
                        break;
                }

                foreach ($protocols as $protocol) {
                    $ipRanges = [];
                    $userIdGroupPair = [];
                    #Kint::dump($inboundRule->getSource(), $group)
                    switch ($inboundRule->getSource()) {
                        case 'any':
                        case 'all':
                        case 'anywhere':
                            $ipRanges[] = [
                                'CidrIp' => "0.0.0.0/0",
                            ];
                            break;
                        case 'self':
                            $userIdGroupPair[] = [
                                'GroupId' => $group['GroupId'],
                                'Description' => "Self-Reference",
                            ];
                            break;
                        default:
                            $ipRanges[] = [
                                'CidrIp' => $inboundRule->getSource(),
                            ];
                    }

                    $ipPermissions[] = array_filter([
                        'FromPort' => $inboundRule->getPort(),
                        'ToPort' => $inboundRule->getPort(),
                        'IpProtocol' => $protocol,
                        'IpRanges' => $ipRanges,
                        'UserIdGroupPairs' => $userIdGroupPair,
                    ]);
                }

                $ingressRequest = array_filter([
                    'GroupId' => $group['GroupId'],
                    //'SourceSecurityGroupId' => $inboundRule->getSource() == 'self' ? $group['GroupId'] : null,
                    'IpPermissions' => $ipPermissions
                ]);
                try {
                    $ingressResponse = $ec2Client->authorizeSecurityGroupIngress($ingressRequest);
                } catch (Ec2Exception $exception) {
                    if (!stripos($exception->getMessage(), "already exists")) {
                        throw $exception;
                    }
                }
            }
        });
        return $this;
    }

    /**
     * @return string
     */
    public function getName(): string
    {
        return $this->name;
    }

    /**
     * @param string $name
     *
     * @return SecurityGroup
     */
    public function setName(string $name): SecurityGroup
    {
        $this->name = $name;
        return $this;
    }

    /**
     * @return SecurityGroupRule[]
     */
    public function getRulesInbound(): array
    {
        return $this->rulesInbound;
    }

    /**
     * @param SecurityGroupRule[] $rulesInbound
     *
     * @return SecurityGroup
     */
    public function setRulesInbound(array $rulesInbound): SecurityGroup
    {
        $this->rulesInbound = $rulesInbound;
        return $this;
    }

    /**
     * @return SecurityGroupRule[]
     */
    public function getRulesOutbound(): array
    {
        return $this->rulesOutbound;
    }

    /**
     * @param SecurityGroupRule[] $rulesOutbound
     *
     * @return SecurityGroup
     */
    public function setRulesOutbound(array $rulesOutbound): SecurityGroup
    {
        $this->rulesOutbound = $rulesOutbound;
        return $this;
    }

    /**
     * @param SecurityGroupRule $rule
     *
     * @return SecurityGroup
     */
    public function addRuleInbound(SecurityGroupRule $rule): SecurityGroup
    {
        $this->rulesInbound[] = $rule;
        return $this;
    }

    /**
     * @param SecurityGroupRule $rule
     *
     * @return SecurityGroup
     */
    public function addRuleOutbound(SecurityGroupRule $rule): SecurityGroup
    {
        $this->rulesOutbound[] = $rule;
        return $this;
    }

    public function parseConfig($config) : SecurityGroup
    {
        if (isset($config['inbound'])) {
            foreach ($config['inbound'] as $inboundRule) {
                $this->addRuleInbound(
                    SecurityGroupRule::Factory($inboundRule)
                );
            }
        }

        if (isset($config['outbound'])) {
            foreach ($config['outbound'] as $outboundRule) {
                $this->addRuleOutbound(
                    SecurityGroupRule::Factory($outboundRule)
                );
            }
        }

        return $this;
    }

    private function getApplicableVpc(Ec2Client $ec2Client) : ?string
    {
        $potentialVPCs = $this->getApplicableVpcIds();
        $availableVPCs = $ec2Client->describeVpcs()->get('Vpcs');
        foreach ($availableVPCs as $availableVPC) {
            if (in_array($availableVPC['VpcId'], $potentialVPCs)) {
                return $availableVPC['VpcId'];
            }
        }
        return null;
    }
}
